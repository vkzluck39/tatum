"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getErc20Decimals = exports.prepareApproveErc20 = exports.sendApproveErc20 = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tatum_1 = require("../connector/tatum");
const token_abi_1 = __importDefault(require("../contracts/erc20/token_abi"));
const helpers_1 = require("../helpers");
const model_1 = require("../model");
const transaction_1 = require("../transaction");
const caver_js_1 = __importDefault(require("caver-js"));
/**
 * Approve ERC20 transfer for spender.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendApproveErc20 = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareApproveErc20(testnet, body, provider), body.signatureId);
exports.sendApproveErc20 = sendApproveErc20;
/**
 * Prepare approve ERC20 signed transaction.
 * @param testnet if we are on testnet or not
 * @param body body of the approve operation
 * @param provider optional Web3 provider
 */
const prepareApproveErc20 = async (testnet, body, provider) => {
    await tatum_1.validateBody(body, model_1.ApproveErc20);
    let amount;
    switch (body.chain) {
        case model_1.Currency.CELO:
            amount = new bignumber_js_1.default(body.amount).multipliedBy(new bignumber_js_1.default(10).pow(await transaction_1.getCeloErc20ContractDecimals(testnet, body.contractAddress, provider))).toString(16);
            break;
        case model_1.Currency.ONE:
            amount = new bignumber_js_1.default(body.amount).multipliedBy(new bignumber_js_1.default(10).pow(await transaction_1.getOne20ContractDecimals(testnet, body.contractAddress, provider))).toString(16);
            break;
        case model_1.Currency.ETH:
            amount = new bignumber_js_1.default(body.amount).multipliedBy(new bignumber_js_1.default(10).pow(await transaction_1.getEthErc20ContractDecimals(testnet, body.contractAddress, provider))).toString(16);
            break;
        case model_1.Currency.BSC:
            amount = new bignumber_js_1.default(body.amount).multipliedBy(new bignumber_js_1.default(10).pow(await transaction_1.getBscBep20ContractDecimals(testnet, body.contractAddress, provider))).toString(16);
            break;
        case model_1.Currency.MATIC:
            amount = new bignumber_js_1.default(body.amount).multipliedBy(new bignumber_js_1.default(10).pow(await transaction_1.getPolygonErc20ContractDecimals(testnet, body.contractAddress, provider))).toString(16);
            break;
        case model_1.Currency.KLAY:
            amount = new bignumber_js_1.default(body.amount).multipliedBy(new bignumber_js_1.default(10).pow(await transaction_1.getKlayErc20ContractDecimals(testnet, body.contractAddress, provider))).toString(16);
            break;
        default:
            throw new Error('Unsupported combination of inputs.');
    }
    const params = [body.spender.trim(), `0x${amount}`];
    body.amount = '0';
    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.ApproveErc20, 'approve', params, undefined, provider, token_abi_1.default);
};
exports.prepareApproveErc20 = prepareApproveErc20;
/**
 * Get Decimals for the ERC20 token
 * @param testnet if we are using testnet or mainnet
 * @param chain chain to query for the token
 * @param contractAddress address of the token
 * @param provider optional provider
 */
const getErc20Decimals = async (testnet, chain, contractAddress, provider) => {
    const web3 = helpers_1.helperGetWeb3Client(testnet, chain, provider);
    const c = web3 instanceof caver_js_1.default ? web3.klay : web3.eth;
    // @ts-ignore
    return (new c.Contract(token_abi_1.default, contractAddress)).methods.decimals().call();
};
exports.getErc20Decimals = getErc20Decimals;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZnVuZ2libGUvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsZ0VBQXFDO0FBQ3JDLDhDQUFrRDtBQUNsRCw2RUFBcUQ7QUFDckQsd0NBQXlGO0FBQ3pGLG9DQUFrRDtBQUNsRCxnREFPd0I7QUFDeEIsd0RBQTRCO0FBRTVCOzs7Ozs7R0FNRztBQUNJLE1BQU0sZ0JBQWdCLEdBQUcsS0FBSyxFQUFFLE9BQWdCLEVBQUUsSUFBa0IsRUFBRSxRQUFpQixFQUFFLEVBQUUsQ0FDaEcsMkJBQWlCLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxNQUFNLDJCQUFtQixDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBRHpGLFFBQUEsZ0JBQWdCLG9CQUN5RTtBQUV0Rzs7Ozs7R0FLRztBQUNJLE1BQU0sbUJBQW1CLEdBQUcsS0FBSyxFQUFFLE9BQWdCLEVBQUUsSUFBa0IsRUFBRSxRQUFpQixFQUFFLEVBQUU7SUFDbkcsTUFBTSxvQkFBWSxDQUFDLElBQUksRUFBRSxvQkFBWSxDQUFDLENBQUM7SUFDdkMsSUFBSSxNQUFNLENBQUM7SUFDWCxRQUFRLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDbEIsS0FBSyxnQkFBUSxDQUFDLElBQUk7WUFDaEIsTUFBTSxHQUFHLElBQUksc0JBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksc0JBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSwwQ0FBNEIsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ2xLLE1BQU07UUFDUixLQUFLLGdCQUFRLENBQUMsR0FBRztZQUNmLE1BQU0s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