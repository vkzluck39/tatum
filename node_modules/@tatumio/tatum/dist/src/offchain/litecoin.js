"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareLitecoinSignedOffchainTransaction = exports.signLitecoinOffchainKMSTransaction = exports.sendLitecoinOffchainTransaction = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
// @ts-ignore
const bitcore_lib_ltc_1 = require("bitcore-lib-ltc");
const tatum_1 = require("../connector/tatum");
const model_1 = require("../model");
const wallet_1 = require("../wallet");
const common_1 = require("./common");
const kms_1 = require("./kms");
/**
 * Send Litecoin transaction from Tatum Ledger account to the blockchain. This method broadcasts signed transaction to the blockchain.
 * This operation is irreversible.
 * @param testnet mainnet or testnet version
 * @param body content of the transaction to broadcast
 * @returns transaction id of the transaction in the blockchain or id of the withdrawal, if it was not cancelled automatically
 */
const sendLitecoinOffchainTransaction = async (testnet, body) => {
    if (body.signatureId) {
        return kms_1.offchainTransferLtcKMS(body);
    }
    await tatum_1.validateBody(body, model_1.TransferBtcBasedOffchain);
    const { mnemonic, keyPair, attr: changeAddress, xpub } = body, withdrawal = __rest(body, ["mnemonic", "keyPair", "attr", "xpub"]);
    if (!withdrawal.fee) {
        withdrawal.fee = '0.0005';
    }
    const { id, data } = await common_1.offchainStoreWithdrawal(withdrawal);
    const { amount, address, } = withdrawal;
    let txData;
    try {
        txData = await exports.prepareLitecoinSignedOffchainTransaction(testnet, data, amount, address, mnemonic, keyPair, changeAddress, xpub, withdrawal.multipleAmounts);
    }
    catch (e) {
        console.error(e);
        await common_1.offchainCancelWithdrawal(id);
        throw e;
    }
    try {
        return Object.assign(Object.assign({}, await common_1.offchainBroadcast({ txData, withdrawalId: id, currency: model_1.Currency.LTC })), { id });
    }
    catch (e) {
        console.error(e);
        try {
            await common_1.offchainCancelWithdrawal(id);
        }
        catch (e1) {
            console.log(e);
            return { id };
        }
        throw e;
    }
};
exports.sendLitecoinOffchainTransaction = sendLitecoinOffchainTransaction;
/**
 * Sign Litecoin pending transaction from Tatum KMS
 * @param tx pending transaction from KMS
 * @param mnemonic mnemonic to generate private keys to sign transaction with.
 * @param testnet mainnet or testnet version
 * @returns transaction data to be broadcast to blockchain.
 */
const signLitecoinOffchainKMSTransaction = async (tx, mnemonic, testnet) => {
    var _a;
    if (tx.chain !== model_1.Currency.LTC || !tx.withdrawalResponses) {
        throw Error('Unsupported chain.');
    }
    const builder = new bitcore_lib_ltc_1.Transaction(JSON.parse(tx.serializedTransaction));
    for (const response of tx.withdrawalResponses) {
        if (response.vIn === '-1') {
            continue;
        }
        builder.sign(bitcore_lib_ltc_1.PrivateKey.fromWIF(await wallet_1.generatePrivateKeyFromMnemonic(model_1.Currency.LTC, testnet, mnemonic, ((_a = response.address) === null || _a === void 0 ? void 0 : _a.derivationKey) || 0)));
    }
    return builder.serialize(true);
};
exports.signLitecoinOffchainKMSTransaction = signLitecoinOffchainKMSTransaction;
/**
 * Sign Litecoin transaction with private keys locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param data data from Tatum system to prepare transaction from
 * @param amount amount to send
 * @param address recipient address, if multiple recipients are present, it should be string separated by ','
 * @param mnemonic mnemonic to sign transaction from. mnemonic or keyPair must be present
 * @param keyPair keyPair to sign transaction from. keyPair or mnemonic must be present
 * @param changeAddress address to send the rest of the unused coins
 * @param xpub xpub of the wallet
 * @param multipleAmounts if multiple recipients are present in the address separated by ',', this should be list of amounts to send
 * @param signatureId if using KMS, this is signatureId of the wallet representing mnemonic
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareLitecoinSignedOffchainTransaction = async (testnet, data, amount, address, mnemonic, keyPair, changeAddress, xpub, multipleAmounts, signatureId) => {
    var _a;
    const tx = new bitcore_lib_ltc_1.Transaction();
    data.forEach((input) => {
        if (input.vIn !== '-1') {
            tx.from({
                txId: input.vIn,
                outputIndex: input.vInIndex,
                script: bitcore_lib_ltc_1.Script.fromAddress(input.address.address).toString(),
                satoshis: Number(new bignumber_js_1.default(input.amount).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR))
            });
        }
    });
    const lastVin = data.find(d => d.vIn === '-1');
    if (multipleAmounts === null || multipleAmounts === void 0 ? void 0 : multipleAmounts.length) {
        for (const [i, multipleAmount] of multipleAmounts.entries()) {
            tx.to(address.split(',')[i], Number(new bignumber_js_1.default(multipleAmount).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR)));
        }
    }
    else {
        tx.to(address, Number(new bignumber_js_1.default(amount).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR)));
    }
    if (new bignumber_js_1.default(lastVin.amount).isGreaterThan(0)) {
        if (xpub) {
            tx.to(wallet_1.generateAddressFromXPub(model_1.Currency.LTC, testnet, xpub, 0), Number(new bignumber_js_1.default(lastVin.amount).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR)));
        }
        else if (changeAddress) {
            tx.to(changeAddress, Number(new bignumber_js_1.default(lastVin.amount).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR)));
        }
        else {
            throw new Error('Impossible to prepare transaction. Either mnemonic or keyPair and attr must be present.');
        }
    }
    if (signatureId) {
        return JSON.stringify(tx);
    }
    for (const input of data) {
        // when there is no address field present, input is pool transfer to 0
        if (input.vIn === '-1') {
            continue;
        }
        if (mnemonic) {
            const derivationKey = ((_a = input.address) === null || _a === void 0 ? void 0 : _a.derivationKey) || 0;
            tx.sign(bitcore_lib_ltc_1.PrivateKey.fromWIF(await wallet_1.generatePrivateKeyFromMnemonic(model_1.Currency.LTC, testnet, mnemonic, derivationKey)));
        }
        else if (keyPair) {
            const { privateKey } = keyPair.find(k => k.address === input.address.address);
            tx.sign(bitcore_lib_ltc_1.PrivateKey.fromWIF(privateKey));
        }
        else {
            throw new Error('Impossible to prepare transaction. Either mnemonic or keyPair and attr must be present.');
        }
    }
    return tx.serialize(true);
};
exports.prepareLitecoinSignedOffchainTransaction = prepareLitecoinSignedOffchainTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGl0ZWNvaW4uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvb2ZmY2hhaW4vbGl0ZWNvaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxnRUFBb0M7QUFDcEMsYUFBYTtBQUNiLHFEQUErRDtBQUMvRCw4Q0FBK0M7QUFDL0Msb0NBQTRHO0FBQzVHLHNDQUFpRjtBQUNqRixxQ0FBNkY7QUFDN0YsK0JBQThDO0FBRTlDOzs7Ozs7R0FNRztBQUNJLE1BQU0sK0JBQStCLEdBQUcsS0FBSyxFQUFFLE9BQWdCLEVBQUUsSUFBOEIsRUFBRSxFQUFFO0lBQ3RHLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtRQUNuQixPQUFPLDRCQUFzQixDQUFDLElBQUksQ0FBQyxDQUFBO0tBQ3JDO0lBQ0QsTUFBTSxvQkFBWSxDQUFDLElBQUksRUFBRSxnQ0FBd0IsQ0FBQyxDQUFBO0lBQ2xELE1BQU0sRUFDRixRQUFRLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsSUFBSSxLQUM1QyxJQUFJLEVBRDZDLFVBQVUsVUFDM0QsSUFBSSxFQUZGLHVDQUVMLENBQU8sQ0FBQTtJQUNSLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFO1FBQ2pCLFVBQVUsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFBO0tBQzVCO0lBQ0QsTUFBTSxFQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUMsR0FBRyxNQUFNLGdDQUF1QixDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQzVELE1BQU0sRUFDRixNQUFNLEVBQUUsT0FBTyxHQUNsQixHQUFHLFVBQVUsQ0FBQTtJQUNkLElBQUksTUFBTSxDQUFBO0lBQ1YsSUFBSTtRQUNBLE1BQU0sR0FBRyxNQUFNLGdEQUF3QyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsVUFBVSxD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