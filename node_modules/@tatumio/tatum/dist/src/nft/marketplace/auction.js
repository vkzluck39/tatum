"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendAuctionSettle = exports.sendAuctionCancel = exports.sendAuctionBid = exports.sendAuctionCreate = exports.sendAuctionApproveErc20Transfer = exports.sendAuctionApproveNftTransfer = exports.sendAuctionUpdateFeeRecipient = exports.sendAuctionUpdateFee = exports.prepareAuctionSettle = exports.prepareAuctionCancel = exports.prepareAuctionBid = exports.prepareAuctionCreate = exports.prepareAuctionApproveErc20Transfer = exports.prepareAuctionApproveNftTransfer = exports.prepareAuctionUpdateFeeRecipient = exports.prepareAuctionUpdateFee = exports.prepareDeployAuction = exports.deployAuction = exports.getAuctionFeeRecipient = exports.getAuction = exports.getAuctionFee = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const tatum_1 = require("../../connector/tatum");
const erc1155_abi_1 = __importDefault(require("../../contracts/erc1155/erc1155_abi"));
const erc721_abi_1 = __importDefault(require("../../contracts/erc721Cashback/erc721_abi"));
const marketplace_1 = require("../../contracts/marketplace");
const fungible_1 = require("../../fungible");
const helpers_1 = require("../../helpers");
const model_1 = require("../../model");
const transaction_1 = require("../../transaction");
const caver_js_1 = __importDefault(require("caver-js"));
/**
 * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuctionFee" target="_blank">Tatum API documentation</a>
 */
const getAuctionFee = async (chain, contractAddress) => tatum_1.get(`/v3/blockchain/auction/auction/${chain}/${contractAddress}/fee`);
exports.getAuctionFee = getAuctionFee;
/**
 * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuction" target="_blank">Tatum API documentation</a>
 */
const getAuction = async (chain, contractAddress, auctionId) => tatum_1.get(`/v3/blockchain/auction/auction/${chain}/${contractAddress}/auction/${auctionId}`);
exports.getAuction = getAuction;
/**
 * For more details, see <a href="https://tatum.io/apidoc#operation/MPAuctionRecipient" target="_blank">Tatum API documentation</a>
 */
const getAuctionFeeRecipient = async (chain, contractAddress) => tatum_1.get(`/v3/blockchain/auction/auction/${chain}/${contractAddress}/recipient`);
exports.getAuctionFeeRecipient = getAuctionFeeRecipient;
/**
 * Deploy new smart contract for NFT auction logic. Smart contract enables auction operator to create new auction for NFT (ERC-721/1155).
 * Operator can set a fee in percentage, which will be paid on top of the price of the asset.
 * can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during auction creation.
 * Before auction is created, seller must approve transfer of the NFT to the auction contract.
 * Buyer will bid for the asset from the auction using native asset - send assets along the gid() smart contract call, or via ERC20 token.
 * Buyer of the auction must perform approval for the smart contract to access ERC20 token, before the actual bid() method is called.
 * Once there is higher bid than the actual one, the previous bidder's funds will be returned to him and new bidder will be the current winning one.
 * When auction ends, anyone can settle the auction - NFT will be sent to the bidder, assets to the seller and fee to the operator.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const deployAuction = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareDeployAuction(testnet, body, provider), body.signatureId);
exports.deployAuction = deployAuction;
/**
 * Prepare signed transaction for NFT auction logic. Smart contract enables auction operator to create new auction for NFT (ERC-721/1155).
 * Operator can set a fee in percentage, which will be paid on top of the price of the asset.
 * can be offered for native asset - ETH, BSC, etc. - or any ERC20 token - this is configurable during auction creation.
 * Before auction is created, seller must approve transfer of the NFT to the auction contract.
 * Buyer will bid for the asset from the auction using native asset - send assets along the gid() smart contract call, or via ERC20 token.
 * Buyer of the auction must perform approval for the smart contract to access ERC20 token, before the actual bid() method is called.
 * Once there is higher bid than the actual one, the previous bidder's funds will be returned to him and new bidder will be the current winning one.
 * When auction ends, anyone can settle the auction - NFT will be sent to the bidder, assets to the seller and fee to the operator.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareDeployAuction = async (testnet, body, provider) => {
    switch (body.chain) {
        case model_1.Currency.CELO:
            return await transaction_1.prepareCeloDeployAuctionSignedTransaction(testnet, body, provider);
        case model_1.Currency.ONE:
            return await transaction_1.prepareOneDeployAuctionSignedTransaction(testnet, body, provider);
        case model_1.Currency.ETH:
            return await transaction_1.prepareEthDeployAuctionSignedTransaction(body, provider);
        case model_1.Currency.BSC:
            return await transaction_1.prepareBscDeployAuctionSignedTransaction(body, provider);
        case model_1.Currency.MATIC:
            return await transaction_1.preparePolygonDeployAuctionSignedTransaction(testnet, body, provider);
        case model_1.Currency.KLAY:
            return await transaction_1.prepareKlaytnDeployAuctionSignedTransaction(testnet, body, provider);
        default:
            throw new Error('Unsupported chain');
    }
};
exports.prepareDeployAuction = prepareDeployAuction;
/**
 * Update auction fee.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareAuctionUpdateFee = async (testnet, body, provider) => {
    await tatum_1.validateBody(body, model_1.UpdateAuctionFee);
    const params = [`0x${new bignumber_js_1.default(body.auctionFee).toString(16)}`];
    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.UpdateAuctionFee, 'setAuctionFee', params, undefined, provider, marketplace_1.auction.abi);
};
exports.prepareAuctionUpdateFee = prepareAuctionUpdateFee;
/**
 * Update auction fee recipient.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareAuctionUpdateFeeRecipient = async (testnet, body, provider) => {
    await tatum_1.validateBody(body, model_1.UpdateMarketplaceFeeRecipient);
    const params = [body.feeRecipient];
    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.UpdateMarketplaceFeeRecipient, 'setAuctionFeeRecipient', params, undefined, provider, marketplace_1.auction.abi);
};
exports.prepareAuctionUpdateFeeRecipient = prepareAuctionUpdateFeeRecipient;
/**
 * Approve NFT transfer for auction to perform listing of the asset.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareAuctionApproveNftTransfer = async (testnet, body, provider) => {
    await tatum_1.validateBody(body, model_1.ApproveNftTransfer);
    const params = body.isErc721 ? [body.spender, `0x${new bignumber_js_1.default(body.tokenId).toString(16)}`] : [body.spender, true];
    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.ApproveNftTransfer, body.isErc721 ? 'approve' : 'setApprovalForAll', params, undefined, provider, body.isErc721 ? erc721_abi_1.default : erc1155_abi_1.default);
};
exports.prepareAuctionApproveNftTransfer = prepareAuctionApproveNftTransfer;
/**
 * Approve ERC20 transfer for auction to perform bidding on the asset in the auction.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareAuctionApproveErc20Transfer = async (testnet, body, provider) => {
    return fungible_1.prepareApproveErc20(testnet, body, provider);
};
exports.prepareAuctionApproveErc20Transfer = prepareAuctionApproveErc20Transfer;
/**
 * Create new auction on the auction contract. Before auction, seller must approve spending of the NFT token for the Auction contract.
 * After auction is created, auction contract transfers the asset to the auction smart contract.
 * Only auction for existing NFTs can be created - seller must be owner of the NFT asset.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareAuctionCreate = async (testnet, body, provider) => {
    await tatum_1.validateBody(body, model_1.CreateAuction);
    const params = [body.id, body.isErc721, body.nftAddress.trim(), `0x${new bignumber_js_1.default(body.tokenId).toString(16)}`,
        body.seller.trim(), `0x${new bignumber_js_1.default(body.amount || 0).toString(16)}`,
        `0x${new bignumber_js_1.default(body.endedAt).toString(16)}`, body.erc20Address || '0x0000000000000000000000000000000000000000'];
    body.amount = undefined;
    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.CreateAuction, 'createAuction', params, undefined, provider, marketplace_1.auction.abi);
};
exports.prepareAuctionCreate = prepareAuctionCreate;
/**
 * Bid on the auction. Buyer must either send native assets with this operation, or approve ERC20 token spending before.
 * After auction is sold, it's in a pending state to be processed by the auction. Noone receives the assets unless the auction operator processes that.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareAuctionBid = async (testnet, body, provider) => {
    await tatum_1.validateBody(body, model_1.InvokeAuctionOperation);
    const web3 = helpers_1.helperGetWeb3Client(testnet, body.chain, provider);
    const c = web3 instanceof caver_js_1.default ? web3.klay : web3.eth;
    // @ts-ignore
    const a = await (new c.Contract(marketplace_1.auction.abi, body.contractAddress)).methods.getAuction(body.id).call();
    let decimals = 18;
    let methodName = 'bid';
    const b = Object.assign({}, body);
    if (a[6] !== '0x0000000000000000000000000000000000000000') {
        // @ts-ignore
        decimals = await fungible_1.getErc20Decimals(testnet, body.chain, a[6], provider);
        if (body.bidder) {
            methodName = 'bidForExternalBidder';
        }
    }
    else if (body.bidder) {
        throw new Error('Bidder could be present only for ERC20 based auctions.');
    }
    else {
        b.amount = body.amount ? body.amount : body.bidValue;
    }
    const params = [body.id, `0x${new bignumber_js_1.default(body.bidValue).multipliedBy(new bignumber_js_1.default(10).pow(decimals)).toString(16)}`];
    if (body.bidder) {
        params.push(body.bidder.trim());
    }
    return await helpers_1.helperPrepareSCCall(testnet, b, model_1.InvokeAuctionOperation, methodName, params, undefined, provider, marketplace_1.auction.abi);
};
exports.prepareAuctionBid = prepareAuctionBid;
/**
 * Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareAuctionCancel = async (testnet, body, provider) => {
    await tatum_1.validateBody(body, model_1.InvokeAuctionOperation);
    const params = [body.id];
    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.InvokeAuctionOperation, 'cancelAuction', params, undefined, provider, marketplace_1.auction.abi);
};
exports.prepareAuctionCancel = prepareAuctionCancel;
/**
 * Settle auction. There must be buyer present for that auction. NFT will be sent to the bidder, assets to the seller and fee to the operator.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const prepareAuctionSettle = async (testnet, body, provider) => {
    await tatum_1.validateBody(body, model_1.InvokeAuctionOperation);
    const params = [body.id];
    return await helpers_1.helperPrepareSCCall(testnet, body, model_1.InvokeAuctionOperation, 'settleAuction', params, undefined, provider, marketplace_1.auction.abi);
};
exports.prepareAuctionSettle = prepareAuctionSettle;
/**
 * Update auction fee.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendAuctionUpdateFee = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareAuctionUpdateFee(testnet, body, provider), body.signatureId);
exports.sendAuctionUpdateFee = sendAuctionUpdateFee;
/**
 * Update auction fee recipient.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendAuctionUpdateFeeRecipient = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareAuctionUpdateFeeRecipient(testnet, body, provider), body.signatureId);
exports.sendAuctionUpdateFeeRecipient = sendAuctionUpdateFeeRecipient;
/**
 * Approve NFT transfer for auction to perform listing of the asset.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendAuctionApproveNftTransfer = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareAuctionApproveNftTransfer(testnet, body, provider), body.signatureId);
exports.sendAuctionApproveNftTransfer = sendAuctionApproveNftTransfer;
/**
 * Approve ERC20 transfer for auction to perform bidding on the asset in the auction.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendAuctionApproveErc20Transfer = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareAuctionApproveErc20Transfer(testnet, body, provider), body.signatureId);
exports.sendAuctionApproveErc20Transfer = sendAuctionApproveErc20Transfer;
/**
 * Create new auction on the auction contract. Before auction, seller must approve spending of the NFT token for the Auction contract.
 * After auction is created, auction contract transfers the asset to the auction smart contract.
 * Only auction for existing NFTs can be created - seller must be owner of the NFT asset.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendAuctionCreate = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareAuctionCreate(testnet, body, provider), body.signatureId);
exports.sendAuctionCreate = sendAuctionCreate;
/**
 * Bid auction on the auction. Buyer must either send native assets with this operation, or approve ERC20 token spending before.
 * After auction is sold, it's in a pending state to be processed by the auction. Noone receives the assets unless the auction operator processes that.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendAuctionBid = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareAuctionBid(testnet, body, provider), body.signatureId);
exports.sendAuctionBid = sendAuctionBid;
/**
 * Cancel auction on the auction. Only possible for the seller or the operator. There must be no buyer present for that auction. NFT asset is sent back to the seller.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendAuctionCancel = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareAuctionCancel(testnet, body, provider), body.signatureId);
exports.sendAuctionCancel = sendAuctionCancel;
/**
 * Settle auction. There must be buyer present for that auction. NFT will be sent to the bidder, assets to the seller and fee to the operator.
 * @param testnet chain to work with
 * @param body request data
 * @param provider optional provider to enter. if not present, Tatum Web3 will be used.
 * @returns {txId: string} Transaction ID of the operation, or signatureID in case of Tatum KMS
 */
const sendAuctionSettle = async (testnet, body, provider) => helpers_1.helperBroadcastTx(body.chain, await exports.prepareAuctionSettle(testnet, body, provider), body.signatureId);
exports.sendAuctionSettle = sendAuctionSettle;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9uZnQvbWFya2V0cGxhY2UvYXVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnRUFBcUM7QUFDckMsaURBQTBEO0FBQzFELHNGQUE4RDtBQUM5RCwyRkFBbUU7QUFDbkUsNkRBQXNEO0FBQ3RELDZDQUF1RTtBQUN2RSwyQ0FBNEY7QUFDNUYsdUNBU3FCO0FBQ3JCLG1EQU8yQjtBQUMzQix3REFBNEI7QUFrRDVCOztHQUVHO0FBQ0ksTUFBTSxhQUFhLEdBQUcsS0FBSyxFQUFFLEtBQWUsRUFBRSxlQUF1QixFQUFtQixFQUFFLENBQy9GLFdBQUcsQ0FBQyxrQ0FBa0MsS0FBSyxJQUFJLGVBQWUsTUFBTSxDQUFDLENBQUM7QUFEM0QsUUFBQSxhQUFhLGlCQUM4QztBQUV4RTs7R0FFRztBQUNJLE1BQU0sVUFBVSxHQUFHLEtBQUssRUFBRSxLQUFlLEVBQUUsZUFBdUIsRUFBRSxTQUFpQixFQUFvQixFQUFFLENBQ2hILFdBQUcsQ0FBQyxrQ0FBa0MsS0FBSyxJQUFJLGVBQWUsWUFBWSxTQUFTLEVBQUUsQ0FBQyxDQUFDO0FBRDVFLFFBQUEsVUFBVSxjQUNrRTtBQUV6Rjs7R0FFRztBQUNJLE1BQU0sc0JBQXNCLEdBQUcsS0FBSyxFQUFFLEtBQWUsRUFBRSxlQUF1QixFQUFnQyxFQUFFLENBQ3JILFdBQUcsQ0FBQyxrQ0FBa0MsS0FBSyxJQUFJLGVBQWUsWUFBWSxDQUFDLENBQUM7QUFEakUsUUFBQSxzQkFBc0IsMEJBQzJDO0FBRzlFOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSSxNQUFNLGFBQWEsR0FBRyxLQUFLLEVBQUUsT0FBZ0IsRUFBRSxJQUFzQixFQUFFLFFBQWlCLEVBQUUsRUFBRSxDQUNqRywyQkFBaUIsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE1BQU0sNEJBQW9CLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLENBQUMs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