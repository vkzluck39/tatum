"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareCreateAccountWithFUSDFromPublicKeyTxTemplate = exports.prepareTransferFlowTxTemplate = exports.prepareAddPublicKeyToAccountTxTemplate = exports.transferFlowNftTokenTxTemplate = exports.burnFlowNftTokenTxTemplate = exports.mintFlowMultipleNftTokenTxTemplate = exports.mintFlowNftTokenTxTemplate = exports.tokenByAddressFlowNftTokenScript = exports.metadataFlowNftTokenScript = exports.deployFlowNftTokenTypeWithMinterTxTemplate = void 0;
const dedent_js_1 = __importDefault(require("dedent-js"));
const constants_1 = require("../../constants");
const deployFlowNftTokenTypeWithMinterTxTemplate = (testnet) => dedent_js_1.default `
import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}

transaction(type: String) {

    // local variable for storing the minter reference
    let minter: &TatumMultiNFT.AdminMinter

    let newMinter: AuthAccount;

    prepare(adminMinter: AuthAccount, newMinter: AuthAccount) {

        // borrow a reference to the NFTMinter resource in storage
        self.minter = adminMinter.borrow<&TatumMultiNFT.AdminMinter>(from: TatumMultiNFT.AdminMinterStoragePath)
            ?? panic("Could not borrow a reference to the NFT minter")
        self.newMinter = newMinter;
    }

    execute {
        // add new minter for specific token type
        self.minter.addMinter(minterAccount: self.newMinter, type: type)
    }
}
`;
exports.deployFlowNftTokenTypeWithMinterTxTemplate = deployFlowNftTokenTypeWithMinterTxTemplate;
const metadataFlowNftTokenScript = (testnet) => dedent_js_1.default `
import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}

pub fun main(account: Address, id: UInt64, type: String): String {
    let collectionRef = getAccount(account)
        .getCapability(TatumMultiNFT.CollectionPublicPath)
        .borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()
        ?? panic("Could not borrow capability from public collection")

    let ref = collectionRef.borrowTatumNFT(id: id, type: type)
    if ref != nil {
      return ref.metadata
    } else {
      return panic("No such token");
    }
}`;
exports.metadataFlowNftTokenScript = metadataFlowNftTokenScript;
const tokenByAddressFlowNftTokenScript = (testnet) => dedent_js_1.default `
import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}

pub fun main(address: Address, type: String): [UInt64] {
    let collectionRef = getAccount(address)
        .getCapability(TatumMultiNFT.CollectionPublicPath)
        .borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()
        ?? panic("Could not borrow capability from public collection")

    return collectionRef.getIDsByType(type: type)
}`;
exports.tokenByAddressFlowNftTokenScript = tokenByAddressFlowNftTokenScript;
const mintFlowNftTokenTxTemplate = (testnet) => dedent_js_1.default `
import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}

transaction(recipient: Address, url: String, type: String) {

    // local variable for storing the minter reference
    let minter: &TatumMultiNFT.NFTMinter

    prepare(signer: AuthAccount) {

        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.borrow<&TatumMultiNFT.NFTMinter>(from: TatumMultiNFT.MinterStoragePath)
            ?? panic("Could not borrow a reference to the NFT minter")
    }

    execute {
        // get the public account object for the recipient
        let recipientAccount = getAccount(recipient)

        // borrow the recipient's public NFT collection reference
        let receiver = recipientAccount
            .getCapability(TatumMultiNFT.CollectionPublicPath)
            .borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()
            ?? panic("Could not get receiver reference to the NFT Collection")

        // mint the NFT and deposit it to the recipient's collection
        self.minter.mintNFT(recipient: receiver, type: type, url: url, address: recipient)
    }
}`;
exports.mintFlowNftTokenTxTemplate = mintFlowNftTokenTxTemplate;
const mintFlowMultipleNftTokenTxTemplate = (testnet) => dedent_js_1.default `
import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}

transaction(recipient: [Address], url: [String], type: String) {

    // local variable for storing the minter reference
    let minter: &TatumMultiNFT.NFTMinter

    prepare(signer: AuthAccount) {

        // borrow a reference to the NFTMinter resource in storage
        self.minter = signer.borrow<&TatumMultiNFT.NFTMinter>(from: TatumMultiNFT.MinterStoragePath)
            ?? panic("Could not borrow a reference to the NFT minter")
    }

    execute {
        var a = 0;
        while a < url.length {
        // get the public account object for the recipient
        let recipientAccount = getAccount(recipient[a])

        // borrow the recipient's public NFT collection reference
        let receiver = recipientAccount
            .getCapability(TatumMultiNFT.CollectionPublicPath)
            .borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()
            ?? panic("Could not get receiver reference to the NFT Collection")

        // mint the NFT and deposit it to the recipient's collection
            self.minter.mintNFT(recipient: receiver, type: type, url: url[a], address: recipient[a])
            a = a + 1
        }
    }
}`;
exports.mintFlowMultipleNftTokenTxTemplate = mintFlowMultipleNftTokenTxTemplate;
const burnFlowNftTokenTxTemplate = (testnet) => dedent_js_1.default `
import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}

transaction(withdrawID: UInt64, type: String) {

    // local variable for storing the minter reference
    let senderCollection: &{TatumMultiNFT.TatumMultiNftCollectionPublic}

    prepare(signer: AuthAccount) {

        // borrow a reference to the signer's NFT collection
        self.senderCollection = signer.borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>(from: TatumMultiNFT.CollectionStoragePath)
            ?? panic("Could not borrow a reference to the owner's collection")

        // check if token has correct type
        self.senderCollection.borrowTatumNFT(id: withdrawID, type: type)
    }

    execute {
        // withdraw the NFT from the owner's collection
        let nft <- self.senderCollection.withdraw(withdrawID: withdrawID)

        // Destroy the nft
        destroy nft
    }
}`;
exports.burnFlowNftTokenTxTemplate = burnFlowNftTokenTxTemplate;
const transferFlowNftTokenTxTemplate = (testnet) => dedent_js_1.default `
import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}

transaction(recipient: Address, withdrawID: UInt64) {

    // local variable for storing the minter reference
    let senderCollection: &{TatumMultiNFT.TatumMultiNftCollectionPublic}

    prepare(signer: AuthAccount) {

        // borrow a reference to the signer's NFT collection
        self.senderCollection = signer.borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>(from: TatumMultiNFT.CollectionStoragePath)
            ?? panic("Could not borrow a reference to the owner's collection")

    }

    execute {
        // get the recipients public account object
        let recipient = getAccount(recipient)

        // borrow a public reference to the receivers collection
        let depositRef = recipient.getCapability(TatumMultiNFT.CollectionPublicPath).borrow<&{TatumMultiNFT.TatumMultiNftCollectionPublic}>()!

        // withdraw the NFT from the owner's collection
        let nft <- self.senderCollection.withdraw(withdrawID: withdrawID)

        // Deposit the NFT in the recipient's collection
        depositRef.deposit(token: <-nft)
    }
}`;
exports.transferFlowNftTokenTxTemplate = transferFlowNftTokenTxTemplate;
const prepareAddPublicKeyToAccountTxTemplate = () => dedent_js_1.default `transaction(publicKey: String) {
prepare(signer: AuthAccount) {
signer.addPublicKey(publicKey.decodeHex())
}
}`;
exports.prepareAddPublicKeyToAccountTxTemplate = prepareAddPublicKeyToAccountTxTemplate;
const prepareTransferFlowTxTemplate = (testnet, tokenAddress, tokenName, tokenStorage) => dedent_js_1.default `import FungibleToken from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.FungibleToken : constants_1.FLOW_MAINNET_ADDRESSES.FungibleToken}
  import ${tokenName} from ${tokenAddress}

transaction(amount: UFix64, recipient: Address) {
  let sentVault: @FungibleToken.Vault
  prepare(signer: AuthAccount) {
    let vaultRef = signer.borrow<&${tokenName}.Vault>(from: /storage/${tokenStorage}Vault)
      ?? panic("failed to borrow reference to sender vault")

    self.sentVault <- vaultRef.withdraw(amount: amount)
  }

  execute {
    let receiverRef =  getAccount(recipient)
      .getCapability(/public/${tokenStorage}Receiver)
      .borrow<&{FungibleToken.Receiver}>()
        ?? panic("failed to borrow reference to recipient vault")

    receiverRef.deposit(from: <-self.sentVault)
  }
}`;
exports.prepareTransferFlowTxTemplate = prepareTransferFlowTxTemplate;
const prepareCreateAccountWithFUSDFromPublicKeyTxTemplate = (testnet) => dedent_js_1.default `import FungibleToken from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.FungibleToken : constants_1.FLOW_MAINNET_ADDRESSES.FungibleToken}
  import FUSD from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.FUSD : constants_1.FLOW_MAINNET_ADDRESSES.FUSD}
  import TatumMultiNFT from ${testnet ? constants_1.FLOW_TESTNET_ADDRESSES.TatumMultiNFT : constants_1.FLOW_MAINNET_ADDRESSES.TatumMultiNFT}
  transaction(publicKey: String) {
    let account: AuthAccount
    prepare(signer: AuthAccount) {
      self.account = AuthAccount(payer: signer)
    }
    execute {
      self.account.addPublicKey(publicKey.decodeHex())
      if self.account.borrow<&TatumMultiNFT.Collection>(from: TatumMultiNFT.CollectionStoragePath) == nil {

            // create a new empty collection
            let collection <- TatumMultiNFT.createEmptyCollection()

            // save it to the account
            self.account.save(<-collection, to: TatumMultiNFT.CollectionStoragePath)

            // create a public capability for the collection
            self.account.link<&TatumMultiNFT.Collection>(TatumMultiNFT.CollectionPublicPath, target: TatumMultiNFT.CollectionStoragePath)
        }
      // Add FUSD vault
      self.account.save(<-FUSD.createEmptyVault(), to: /storage/fusdVault)
      self.account.link<&FUSD.Vault{FungibleToken.Receiver}>(
          /public/fusdReceiver,
          target: /storage/fusdVault
      )
      self.account.link<&FUSD.Vault{FungibleToken.Balance}>(
          /public/fusdBalance,
          target: /storage/fusdVault
      )
    }
  }
  `;
exports.prepareCreateAccountWithFUSDFromPublicKeyTxTemplate = prepareCreateAccountWithFUSDFromPublicKeyTxTemplate;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvdHJhbnNhY3Rpb24vZmxvd1RyYW5zYWN0aW9uL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDBEQUE4QjtBQUM5QiwrQ0FBOEU7QUFFdkUsTUFBTSwwQ0FBMEMsR0FBRyxDQUFDLE9BQWdCLEVBQUUsRUFBRSxDQUFDLG1CQUFNLENBQUE7NEJBQzFELE9BQU8sQ0FBQyxDQUFDLENBQUMsa0NBQXNCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxrQ0FBc0IsQ0FBQyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0JoSCxDQUFBO0FBdkJZLFFBQUEsMENBQTBDLDhDQXVCdEQ7QUFFTSxNQUFNLDBCQUEwQixHQUFHLENBQUMsT0FBZ0IsRUFBRSxFQUFFLENBQUMsbUJBQU0sQ0FBQTs0QkFDMUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxrQ0FBc0IsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLGtDQUFzQixDQUFDLGFBQWE7Ozs7Ozs7Ozs7Ozs7O0VBYy9HLENBQUE7QUFmVyxRQUFBLDBCQUEwQiw4QkFlckM7QUFHSyxNQUFNLGdDQUFnQyxHQUFHLENBQUMsT0FBZ0IsRUFBRSxFQUFFLENBQUMsbUJBQU0sQ0FBQTs0QkFDaEQsT0FBTyxDQUFDLENBQUMsQ0FBQyxrQ0FBc0IsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLGtDQUFzQixDQUFDLGFBQWE7Ozs7Ozs7OztFQVMvRyxDQUFBO0FBVlcsUUFBQSxnQ0FBZ0Msb0NBVTNDO0FBRUssTUFBTSwwQkFBMEIsR0FBRyxDQUFDLE9BQWdCLEVBQUUsRUFBRSxDQUFDLG1CQUFNLENBQUE7NEJBQzFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsa0NBQXNCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxrQ0FBc0IsQ0FBQyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEyQi9HLENBQUE7QUE1QlcsUUFBQSwwQkFBMEIsOEJBNEJyQztBQUVLLE1BQU0sa0NBQWtDLEdBQUcsQ0FBQyxPQUFnQixFQUFFLEVBQUUsQ0FBQyxtQkFBTSxDQUFBOzRCQUNsRCxPQUFPLENBQUMsQ0FBQyxDQUFDLGtDQUFzQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsa0NBQXNCLENBQUMsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQStCL0csQ0FBQTtBQWhDVyxRQUFBLGtDQUFrQyxzQ0FnQzdDO0FBRUssTUFBTSwwQkFBMEIsR0FBRyxDQUFDLE9BQWdCLEVBQUUsRUFBRSxDQUFDLG1CQUFNLENBQUE7NEJBQzFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsa0NBQXNCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxrQ0FBc0IsQ0FBQyxhQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF3Qi9HLENBQUE7QUF6QlcsUUFBQSwwQkFBMEIsOEJBeUJyQztBQUVLLE1BQU0sOEJBQThCLEdBQUcsQ0FBQyxPQUFnQixFQUFFLEVBQUUsQ0FBQyxtQkFBTSxDQUFBOzRCQUM5QyxPQUFPLENBQUMsQ0FBQyxDQUFDLGtDQUFzQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsa0NBQXNCLENBQUMsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQTRCL0csQ0FBQTtBQTdCVyxRQUFBLDhCQUE4QixrQ0E2QnpDO0FBRUssTUFBTSxzQ0FBc0MsR0FBRyxHQUFHLEVBQUUsQ0FDdkQsbUJBQU0sQ0FBQTs7OztFQUlSLENBQUE7QUFMVyxRQUFBLHNDQUFzQywwQ0FLakQ7QUFFSyxNQUFNLDZCQUE2QixHQUFHLENBQUMsT0FBZ0IsRUFBRSxZQUFvQixFQUFFLFNBQWlCLEVBQUUsWUFBb0IsRUFBRSxFQUFFLENBQzdILG1CQUFNLENBQUEsNkJBQTZCLE9BQU8sQ0FBQyxDQUFDLENBQUMsa0NBQXNCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxrQ0FBc0IsQ0FBQyxhQUFhO1dBQ2pILFNBQVMsU0FBUyxZQUFZOzs7OztvQ0FLTCxTQUFTLDBCQUEwQixZQUFZOzs7Ozs7OzsrQkFRcEQsWUFBWTs7Ozs7O0VBTXpDLENBQUE7QUFyQlcsUUFBQSw2QkFBNkIsaUNBcUJ4QztBQUVLLE1BQU0sbURBQW1ELEdBQUcsQ0FBQyxPQUFnQixFQUFFLEVBQUUsQ0FDcEYsbUJBQU0sQ0FBQSw2QkFBNkIsT0FBTyxDQUFDLENBQUMsQ0FBQyxrQ0FBc0IsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLGtDQUFzQixDQUFDLGFBQWE7cUJBQ3ZHLE9BQU8sQ0FBQyxDQUFDLENBQUMsa0NBQXNCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxrQ0FBc0IsQ0FBQyxJQUFJOzhCQUMxRCxPQUFPLENBQUMsQ0FBQyxDQUFDLGtDQUFzQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsa0NBQXNCLENBQUMsYUFBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQStCaEgsQ0FBQTtBQWxDVSxRQUFBLG1EQUFtRCx1REFrQzdEIn0=