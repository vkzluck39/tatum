"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendBitcoinTransaction = exports.prepareBitcoinSignedTransaction = exports.signBitcoinKMSTransaction = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
// @ts-ignore
const bitcore_lib_1 = require("bitcore-lib");
const blockchain_1 = require("../blockchain");
const tatum_1 = require("../connector/tatum");
const model_1 = require("../model");
/**
 * Prepare a signed Btc transaction with the private key locally. Nothing is broadcasted to the blockchain.
 * @returns raw transaction data in hex, to be broadcasted to blockchain.
 */
const prepareSignedTransaction = async (body) => {
    var _a, _b;
    await tatum_1.validateBody(body, model_1.TransferBtcBasedBlockchain);
    const { fromUTXO, fromAddress, to } = body;
    const tx = new bitcore_lib_1.Transaction();
    const privateKeysToSign = [];
    if (fromAddress) {
        for (const item of fromAddress) {
            const txs = await blockchain_1.btcGetTxForAccount(item.address);
            for (const t of txs) {
                for (const [i, o] of t.outputs.entries()) {
                    if (o.address !== item.address) {
                        continue;
                    }
                    try {
                        await blockchain_1.btcGetUTXO(t.hash, i);
                        tx.from({
                            txId: t.hash,
                            outputIndex: i,
                            script: bitcore_lib_1.Script.fromAddress(item.address).toString(),
                            satoshis: o.value,
                        });
                        privateKeysToSign.push(item.signatureId || item.privateKey);
                    }
                    catch (e) {
                        console.error(e.toString());
                    }
                }
            }
        }
    }
    else if (fromUTXO) {
        for (const item of fromUTXO) {
            const t = await blockchain_1.btcGetTransaction(item.txHash);
            const address = t.outputs ? t.outputs[item.index].address : (_a = t.vout) === null || _a === void 0 ? void 0 : _a[item.index].scriptPubKey.addresses[0];
            const value = t.outputs ? t.outputs[item.index].value :
                Number(new bignumber_js_1.default(((_b = t.vout) === null || _b === void 0 ? void 0 : _b[item.index].value) || 0).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR));
            tx.from({
                txId: item.txHash,
                outputIndex: item.index,
                script: bitcore_lib_1.Script.fromAddress(address).toString(),
                satoshis: value,
            });
            privateKeysToSign.push(item.signatureId || item.privateKey);
        }
    }
    for (const item of to) {
        tx.to(item.address, Number(new bignumber_js_1.default(item.value).multipliedBy(100000000).toFixed(8, bignumber_js_1.default.ROUND_FLOOR)));
    }
    if ((fromAddress && fromAddress[0].signatureId) || (fromUTXO && fromUTXO[0].signatureId)) {
        return JSON.stringify({ txData: JSON.stringify(tx), privateKeysToSign });
    }
    for (const item of privateKeysToSign) {
        tx.sign(bitcore_lib_1.PrivateKey.fromWIF(item));
    }
    return tx.serialize(true);
};
/**
 * Sign Bitcoin pending transaction from Tatum KMS
 * @param tx pending transaction from KMS
 * @param privateKeys private keys to sign transaction with.
 * @param testnet mainnet or testnet version
 * @returns transaction data to be broadcast to blockchain.
 */
const signBitcoinKMSTransaction = async (tx, privateKeys) => {
    if (tx.chain !== model_1.Currency.BTC) {
        throw Error('Unsupported chain.');
    }
    const builder = new bitcore_lib_1.Transaction(JSON.parse(tx.serializedTransaction));
    for (const privateKey of privateKeys) {
        builder.sign(bitcore_lib_1.PrivateKey.fromWIF(privateKey));
    }
    return builder.serialize(true);
};
exports.signBitcoinKMSTransaction = signBitcoinKMSTransaction;
/**
 * Sign Bitcoin transaction with private keys locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param body content of the transaction to broadcast
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareBitcoinSignedTransaction = async (testnet, body) => {
    return prepareSignedTransaction(body);
};
exports.prepareBitcoinSignedTransaction = prepareBitcoinSignedTransaction;
/**
 * Send Bitcoin transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * This operation is irreversible.
 * @param testnet mainnet or testnet version
 * @param body content of the transaction to broadcast
 * @returns transaction id of the transaction in the blockchain
 */
const sendBitcoinTransaction = async (testnet, body) => {
    return blockchain_1.btcBroadcast(await exports.prepareBitcoinSignedTransaction(testnet, body));
};
exports.sendBitcoinTransaction = sendBitcoinTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYml0Y29pbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90cmFuc2FjdGlvbi9iaXRjb2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLGdFQUFxQztBQUNyQyxhQUFhO0FBQ2IsNkNBQTREO0FBQzVELDhDQUErRjtBQUMvRiw4Q0FBZ0Q7QUFDaEQsb0NBQTRGO0FBRTVGOzs7R0FHRztBQUNILE1BQU0sd0JBQXdCLEdBQUcsS0FBSyxFQUFFLElBQWdDLEVBQUUsRUFBRTs7SUFDeEUsTUFBTSxvQkFBWSxDQUFDLElBQUksRUFBRSxrQ0FBMEIsQ0FBQyxDQUFDO0lBQ3JELE1BQU0sRUFBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBQyxHQUFHLElBQUksQ0FBQztJQUN6QyxNQUFNLEVBQUUsR0FBRyxJQUFJLHlCQUFXLEVBQUUsQ0FBQztJQUM3QixNQUFNLGlCQUFpQixHQUFHLEVBQUUsQ0FBQztJQUM3QixJQUFJLFdBQVcsRUFBRTtRQUNiLEtBQUssTUFBTSxJQUFJLElBQUksV0FBVyxFQUFFO1lBQzVCLE1BQU0sR0FBRyxHQUFHLE1BQU0sK0JBQWtCLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ25ELEtBQUssTUFBTSxDQUFDLElBQUksR0FBRyxFQUFFO2dCQUNqQixLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUssQ0FBQyxDQUFDLE9BQTBCLENBQUMsT0FBTyxFQUFFLEVBQUU7b0JBQzFELElBQUksQ0FBQyxDQUFDLE9BQU8sS0FBSyxJQUFJLENBQUMsT0FBTyxFQUFFO3dCQUM1QixTQUFRO3FCQUNYO29CQUNELElBQUk7d0JBQ0EsTUFBTSx1QkFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUE7d0JBQzNCLEVBQUUsQ0FBQyxJQUFJLENBQUM7NEJBQ0osSUFBSSxFQUFFLENBQUMsQ0FBQyxJQUFJOzRCQUNaLFdBQVcsRUFBRSxD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