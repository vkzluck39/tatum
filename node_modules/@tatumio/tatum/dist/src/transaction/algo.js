"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendAlgoBurnFTSignedTransaction = exports.prepareAlgoBurnFTSignedTransaction = exports.sendAlgoTransferFTSignedTransaction = exports.prepareAlgoTransferFTSignedTransaction = exports.sendAlgoCreateFTSignedTransaction = exports.prepareAlgoCreateFTSignedTransaction = exports.sendAlgoBurnFractionalNFTSignedTransaction = exports.prepareAlgoBurnFractionalNFTSignedTransaction = exports.sendAlgoTransferFractionalNFTSignedTransaction = exports.prepareAlgoTransferFractionalNFTSignedTransaction = exports.sendAlgoCreateFractionalNFTSignedTransaction = exports.prepareAlgoCreateFractionalNFTSignedTransaction = exports.sendAlgoBurnNFTSignedTransaction = exports.prepareAlgoBurnNFTSignedTransaction = exports.sendAlgoReceiveNFTSignedTransaction = exports.sendAlgoTransferNFTSignedTransaction = exports.prepareAlgoReceiveNFTSignedTransaction = exports.prepareAlgoTransferNFTSignedTransaction = exports.sendAlgoCreateNFTSignedTransaction = exports.prepareAlgoCreateNFTSignedTransaction = exports.signAlgoKMSTransaction = exports.sendAlgoSignedTransaction = exports.prepareAlgoSignedTransaction = exports.getAlgoIndexerClient = exports.getAlgoClient = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const util_1 = require("util");
const blockchain_1 = require("../blockchain");
const model_1 = require("../model");
const wallet_1 = require("../wallet");
const algosdk = require('algosdk');
const base32 = require('base32.js');
const Url = require('url-parse');
/**
 * Algod V2 Client
 * @param testnet if the algorand node is testnet or not
 * @param provider url of the algorand server endpoint
 * @returns algorand Client
 */
const getAlgoClient = (testnet, provider) => {
    if (provider) {
        return new algosdk.Algodv2(`${(testnet ? process.env.TATUM_ALGORAND_TESTNET_TOKEN : process.env.TATUM_ALGORAND_MAINNET_TOKEN) || 'DUMMYTOKEN'}`, provider, Url(provider).port);
    }
    else {
        return new algosdk.Algodv2({ 'X-API-Key': testnet ? `${process.env.TATUM_ALGORAND_TESTNET_THIRD_API_KEY}` : `${process.env.TATUM_ALGORAND_MAINNET_THIRD_API_KEY}` }, testnet ? `${process.env.TATUM_ALGORAND_TESTNET_THIRD_API_ALGOD_URL}` : `${process.env.TATUM_ALGORAND_MAINNET_THIRD_API_ALGOD_URL}`, '');
    }
};
exports.getAlgoClient = getAlgoClient;
/**
 * Algo Indexer Client
 * @param testnet if the algorand node is testnet or not
 * @param provider url of the algorand server endpoint
 * @returns algorand Indexer Client
 */
const getAlgoIndexerClient = (testnet, provider) => {
    if (provider) {
        return new algosdk.Indexer(`${(testnet ? process.env.TATUM_ALGORAND_TESTNET_TOKEN : process.env.TATUM_ALGORAND_MAINNET_TOKEN) || 'DUMMYTOKEN'}`, provider, Url(provider).port);
    }
    else {
        return new algosdk.Indexer({ 'X-API-Key': testnet ? `${process.env.TATUM_ALGORAND_TESTNET_THIRD_API_KEY}` : `${process.env.TATUM_ALGORAND_MAINNET_THIRD_API_KEY}` }, testnet ? `${process.env.TATUM_ALGORAND_TESTNET_THIRD_API_INDEXER_URL}` : `${process.env.TATUM_ALGORAND_MAINNET_THIRD_API_INDEXER_URL}`, '');
    }
};
exports.getAlgoIndexerClient = getAlgoIndexerClient;
/**
 * Algorand transaction signing
 * @param testnet if the algorand node is testnet or not
 * @param tx content of the transaction to broadcast
 * @param provider url of the algorand server endpoint for purestake.io restapi
 * @returns transaction data to be broadcast to blockchain
 */
const prepareAlgoSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const enc = new util_1.TextEncoder();
    const note = enc.encode(tx.note ? tx.note : '');
    const txn = algosdk.makePaymentTxnWithSuggestedParams(tx.from, tx.to, new bignumber_js_1.default(tx.amount).multipliedBy(1000000).toNumber(), undefined, note, Object.assign(Object.assign({}, params), { fee: new bignumber_js_1.default(tx.fee).multipliedBy(1000000).toNumber(), flatFee: true }));
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoSignedTransaction = prepareAlgoSignedTransaction;
/**
 * Send Algorand transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * This operation is irreversible.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain
 */
const sendAlgoSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoSignedTransaction = sendAlgoSignedTransaction;
/**
 * Sign Algorand pending transaction from Tatum KMS
 * @param tx pendding transaction from Tatum KMS
 * @param fromPrivateKey private key to sign transaction with
 * @param testnet mainnet or testnet version
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const signAlgoKMSTransaction = async (tx, fromPrivateKey, testnet, provider) => {
    if (tx.chain !== model_1.Currency.ALGO) {
        throw Error('Unsupported chain.');
    }
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = JSON.parse(tx.serializedTransaction);
    txn.from = algosdk.encodeAddress(new Uint8Array(Object.values(txn.from.publicKey)));
    txn.to = algosdk.encodeAddress(new Uint8Array(Object.values(txn.to.publicKey)));
    txn.note = new Uint8Array(Object.values(txn.note || ''));
    txn.lease = undefined;
    if (txn.tag) {
        if (txn.tag.data) {
            txn.tag = Buffer.from(txn.tag.data);
        }
    }
    txn.genesisHash = Buffer.from(txn.genesisHash.data);
    if (txn.assetManager) {
        txn.assetManager = algosdk.encodeAddress(new Uint8Array(Object.values(txn.assetManager.publicKey)));
    }
    if (txn.assetReserve) {
        txn.assetReserve = undefined;
    }
    if (txn.assetFreeze) {
        txn.assetFreeze = undefined;
    }
    if (txn.assetClawback) {
        txn.assetClawback = undefined;
    }
    if (txn.assetRevocationTarget) {
        txn.assetRevocationTarget = undefined;
    }
    if (txn.reKeyTo) {
        txn.reKeyTo = undefined;
    }
    if (txn.assetMetadataHash) {
        txn.assetMetadataHash = new Uint8Array(Object.values(txn.assetMetadataHash));
    }
    const _txn = new (algosdk.Transaction)(txn);
    const secretKey = new Uint8Array(decoder.write(fromPrivateKey).buf);
    return Buffer.from(_txn.signTxn(secretKey)).toString('hex');
};
exports.signAlgoKMSTransaction = signAlgoKMSTransaction;
/**
 * Sign Algorand create NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain
 */
const prepareAlgoCreateNFTSignedTransaction = async (testnet, tx, provider) => {
    var _a, _b, _c, _d, _e;
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetCreateTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, 1, 0, false, (_a = tx.attr) === null || _a === void 0 ? void 0 : _a.manager, (_b = tx.attr) === null || _b === void 0 ? void 0 : _b.reserve, (_c = tx.attr) === null || _c === void 0 ? void 0 : _c.freeze, (_d = tx.attr) === null || _d === void 0 ? void 0 : _d.clawback, (_e = tx.attr) === null || _e === void 0 ? void 0 : _e.assetUnit, tx.name, tx.url, undefined, params);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoCreateNFTSignedTransaction = prepareAlgoCreateNFTSignedTransaction;
/**
 * Send Algorand create NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain
 */
const sendAlgoCreateNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoCreateNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoCreateNFTSignedTransaction = sendAlgoCreateNFTSignedTransaction;
/**
 * Sign Algorand transfer NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoTransferNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetTransferTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, tx.to, undefined, undefined, 1, undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoTransferNFTSignedTransaction = prepareAlgoTransferNFTSignedTransaction;
/**
 * Sign Algorand receive NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoReceiveNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const from = tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from;
    const txn = algosdk.makeAssetTransferTxnWithSuggestedParams(from, from, undefined, undefined, 0, undefined, tx.assetId, params);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoReceiveNFTSignedTransaction = prepareAlgoReceiveNFTSignedTransaction;
/**
 * Send Algorand Transfer NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoTransferNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoTransferNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoTransferNFTSignedTransaction = sendAlgoTransferNFTSignedTransaction;
/**
 * Send Algorand Receive NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoReceiveNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoReceiveNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoReceiveNFTSignedTransaction = sendAlgoReceiveNFTSignedTransaction;
/**
 * Sign Algorand burn NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoBurnNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetDestroyTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoBurnNFTSignedTransaction = prepareAlgoBurnNFTSignedTransaction;
/**
 * Send Algorand burn NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoBurnNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoBurnNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoBurnNFTSignedTransaction = sendAlgoBurnNFTSignedTransaction;
/**
 * Sign Algorand create Fractional NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoCreateFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const v = Math.floor(Math.log10(new bignumber_js_1.default(tx.amount).toNumber()));
    const txn = algosdk.makeAssetCreateTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(10).pow(v).toNumber(), v, false, tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, undefined, undefined, tx.tokenId, tx.contractAddress, tx.url, undefined, params);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoCreateFractionalNFTSignedTransaction = prepareAlgoCreateFractionalNFTSignedTransaction;
/**
 * Send Algorand create Fractinoal NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoCreateFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoCreateFractionalNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoCreateFractionalNFTSignedTransaction = sendAlgoCreateFractionalNFTSignedTransaction;
/**
 * Sign Algorand transfer Fractional NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoTransferFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetTransferTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, tx.to, undefined, undefined, new bignumber_js_1.default(tx.amount).toNumber(), undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoTransferFractionalNFTSignedTransaction = prepareAlgoTransferFractionalNFTSignedTransaction;
/**
 * Send Algorand transfer Fractinoal NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoTransferFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoTransferFractionalNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoTransferFractionalNFTSignedTransaction = sendAlgoTransferFractionalNFTSignedTransaction;
/**
 * Sign Algorand burn Fracational NFT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connecto to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoBurnFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetDestroyTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoBurnFractionalNFTSignedTransaction = prepareAlgoBurnFractionalNFTSignedTransaction;
/**
 * Send Algorand burn Fractional NFT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoBurnFractionalNFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoBurnFractionalNFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoBurnFractionalNFTSignedTransaction = sendAlgoBurnFractionalNFTSignedTransaction;
/**
 * Sign Algorand create FT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connnect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoCreateFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetCreateTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(tx.supply).shiftedBy(new bignumber_js_1.default(tx.digits).toNumber()).toNumber(), new bignumber_js_1.default(tx.digits).toNumber(), false, tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, undefined, undefined, tx.symbol, tx.name, tx.url, undefined, params);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoCreateFTSignedTransaction = prepareAlgoCreateFTSignedTransaction;
/**
 * Send Algorand create FT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoCreateFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoCreateFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoCreateFTSignedTransaction = sendAlgoCreateFTSignedTransaction;
/**
 * Sign Algorand transfer FT transaction with private kwy locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoTransferFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetTransferTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, tx.to, undefined, undefined, new bignumber_js_1.default(tx.amount).shiftedBy(tx.digits || 1).toNumber(), undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoTransferFTSignedTransaction = prepareAlgoTransferFTSignedTransaction;
/**
 * Send Algorand transfer FT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoTransferFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoTransferFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoTransferFTSignedTransaction = sendAlgoTransferFTSignedTransaction;
/**
 * Sign ALgorand burn FT transaction with private key locally. Nothing is broadcast to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareAlgoBurnFTSignedTransaction = async (testnet, tx, provider) => {
    const algodClient = exports.getAlgoClient(testnet, provider);
    const params = await algodClient.getTransactionParams().do();
    const decoder = new base32.Decoder({ type: 'rfc4648' });
    const txn = algosdk.makeAssetDestroyTxnWithSuggestedParams(tx.fromPrivateKey ? wallet_1.generateAlgodAddressFromPrivatetKey(tx.fromPrivateKey) : tx.from, undefined, new bignumber_js_1.default(tx.contractAddress).toNumber(), params, undefined);
    if (tx.signatureId) {
        return JSON.stringify(txn);
    }
    const secretKey = new Uint8Array(decoder.write(tx.fromPrivateKey).buf);
    return Buffer.from(txn.signTxn(secretKey)).toString('hex');
};
exports.prepareAlgoBurnFTSignedTransaction = prepareAlgoBurnFTSignedTransaction;
/**
 * Sned Algorand burn FT transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * @param testnet mainnet or testnet version
 * @param tx content of the transaction to broadcast
 * @param provider url of the Algorand Server to connect to. If not set, default public server will be used.
 * @returns transaction id of the transaction in the blockchain.
 */
const sendAlgoBurnFTSignedTransaction = async (testnet, tx, provider) => {
    return (await blockchain_1.algorandBroadcast(await exports.prepareAlgoBurnFTSignedTransaction(testnet, tx, provider)));
};
exports.sendAlgoBurnFTSignedTransaction = sendAlgoBurnFTSignedTransaction;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWxnby5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90cmFuc2FjdGlvbi9hbGdvLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLGdFQUFxQztBQUNyQywrQkFBbUM7QUFDbkMsOENBQWtEO0FBQ2xELG9DQWNrQjtBQUNsQixzQ0FBK0Q7QUFFL0QsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ25DLE1BQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUVwQyxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDakM7Ozs7O0dBS0c7QUFDSSxNQUFNLGFBQWEsR0FBRyxDQUFDLE9BQWdCLEVBQUUsUUFBaUIsRUFBZSxFQUFFO0lBQ2hGLElBQUksUUFBUSxFQUFFO1FBQ1osT0FBTyxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxJQUFJLFlBQVksRUFBRSxFQUFFLFFBQVEsRUFBRSxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7S0FDaEw7U0FBTTtRQUNMLE9BQU8sSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLG9DQUFvQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQ0FBb0MsRUFBRSxFQUFFLEVBQ2pLLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLDBDQUEwQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyww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