"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareXrpSignedTransaction = exports.signXrpKMSTransaction = exports.sendXrpTransaction = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const ripple_lib_1 = require("ripple-lib");
const blockchain_1 = require("../blockchain");
const tatum_1 = require("../connector/tatum");
const model_1 = require("../model");
/**
 * Send Xrp transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
 * This operation is irreversible.
 * @param body content of the transaction to broadcast
 * @returns transaction id of the transaction in the blockchain
 */
const sendXrpTransaction = async (body) => {
    return blockchain_1.xrpBroadcast(await exports.prepareXrpSignedTransaction(body));
};
exports.sendXrpTransaction = sendXrpTransaction;
/**
 * Sign Xrp pending transaction from Tatum KMS
 * @param tx pending transaction from KMS
 * @param secret secret key to sign transaction with.
 * @returns transaction data to be broadcast to blockchain.
 */
const signXrpKMSTransaction = async (tx, secret) => {
    if (tx.chain !== model_1.Currency.XRP) {
        throw Error('Unsupported chain.');
    }
    const rippleAPI = new ripple_lib_1.RippleAPI();
    return rippleAPI.sign(tx.serializedTransaction, secret).signedTransaction;
};
exports.signXrpKMSTransaction = signXrpKMSTransaction;
/**
 * Sign Xrp transaction with private keys locally. Nothing is broadcast to the blockchain.
 * @param body content of the transaction to broadcast
 * @returns transaction data to be broadcast to blockchain.
 */
const prepareXrpSignedTransaction = async (body) => {
    await tatum_1.validateBody(body, model_1.TransferXrp);
    const { fromAccount, fromSecret, to, amount, fee, sourceTag, destinationTag, } = body;
    const f = fee ? fee : new bignumber_js_1.default((await blockchain_1.xrpGetFee()).drops.base_fee).dividedBy(1000000).toString();
    const payment = {
        source: {
            address: fromAccount,
            maxAmount: {
                currency: 'XRP',
                value: amount,
            },
            tag: sourceTag,
        },
        destination: {
            address: to,
            amount: {
                currency: 'XRP',
                value: amount,
            },
            tag: destinationTag,
        },
    };
    const accountInfo = await blockchain_1.xrpGetAccountInfo(fromAccount);
    const sequence = accountInfo.account_data.Sequence;
    const maxLedgerVersion = (accountInfo.ledger_current_index || accountInfo.ledger_index) + 500;
    const rippleAPI = new ripple_lib_1.RippleAPI();
    const prepared = await rippleAPI.preparePayment(fromAccount, payment, {
        fee: f,
        sequence,
        maxLedgerVersion,
    });
    const signed = await rippleAPI.sign(prepared.txJSON, fromSecret);
    return signed.signedTransaction;
};
exports.prepareXrpSignedTransaction = prepareXrpSignedTransaction;
// TODO: add support for ModifyAccount and TrustLine
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieHJwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3RyYW5zYWN0aW9uL3hycC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxnRUFBb0M7QUFDcEMsMkNBQW9DO0FBRXBDLDhDQUF3RTtBQUN4RSw4Q0FBK0M7QUFDL0Msb0NBQThEO0FBRTlEOzs7OztHQUtHO0FBQ0ksTUFBTSxrQkFBa0IsR0FBRyxLQUFLLEVBQUUsSUFBaUIsRUFBRSxFQUFFO0lBQzFELE9BQU8seUJBQVksQ0FBQyxNQUFNLG1DQUEyQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7QUFDaEUsQ0FBQyxDQUFBO0FBRlksUUFBQSxrQkFBa0Isc0JBRTlCO0FBRUQ7Ozs7O0dBS0c7QUFDSSxNQUFNLHFCQUFxQixHQUFHLEtBQUssRUFBRSxFQUFrQixFQUFFLE1BQWMsRUFBRSxFQUFFO0lBQzlFLElBQUksRUFBRSxDQUFDLEtBQUssS0FBSyxnQkFBUSxDQUFDLEdBQUcsRUFBRTtRQUMzQixNQUFNLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFBO0tBQ3BDO0lBQ0QsTUFBTSxTQUFTLEdBQUcsSUFBSSxzQkFBUyxFQUFFLENBQUE7SUFDakMsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsRUFBRSxNQUFNLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQTtBQUM3RSxDQUFDLENBQUE7QUFOWSxRQUFBLHFCQUFxQix5QkFNakM7QUFFRDs7OztHQUlHO0FBQ0ksTUFBTSwyQkFBMkIsR0FBRyxLQUFLLEVBQUUsSUFBaUIsRUFBRSxFQUFFO0lBQ25FLE1BQU0sb0JBQVksQ0FBQyxJQUFJLEVBQUUsbUJBQVcsQ0FBQyxDQUFBO0lBQ3JDLE1BQU0sRUFDRixXQUFXLEVBQ1gsVUFBVSxFQUNWLEVBQUUsRUFDRixNQUFNLEVBQ04sR0FBRyxFQUNILFNBQVMsRUFDVCxjQUFjLEdBQ2pCLEdBQUcsSUFBSSxDQUFBO0lBRVIsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksc0JBQVMsQ0FBQyxDQUFDLE1BQU0sc0JBQVMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQTtJQUNyRyxNQUFNLE9BQU8sR0FBWTtRQUNyQixNQUFNLEVBQUU7WUFDSixPQUFPLEVBQUUsV0FBVztZQUNwQixTQUFTLEVBQUU7Z0JBQ1AsUUFBUSxFQUFFLEtBQUs7Z0JBQ2YsS0FBSyxFQUFFLE1BQU07YUFDaEI7WUFDRCxHQUFHLEVBQUUsU0FBUztTQUNqQjtRQUNELFdBQVcsRUFBRTtZQUNULE9BQU8sRUFBRSxFQUFFO1lBQ1gsTUFBTSxFQUFFO2dCQUNKLFFBQVEsRUFBRSxLQUFLO2dCQUNmLEtBQUssRUFBRSxNQUFNO2FBQ2hCO1lBQ0QsR0FBRyxFQUFFLGNBQWM7U0FDdEI7S0FDSixDQUFBO0lBQ0QsTUFBTSxXQUFXLEdBQUcsTUFBTSw4QkFBaUIsQ0FBQyxXQUFXLENBQUMsQ0FBQTtJQUN4RCxNQUFNLFFBQVEsR0FBRyxXQUFXLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQTtJQUNsRCxNQUFNLGdCQUFnQixHQUFHLENBQUMsV0FBVyxDQUFDLG9CQUFvQixJQUFJLFdBQVcsQ0FBQyxZQUFZLENBQUMsR0FBRyxHQUFHLENBQUE7SUFDN0YsTUFBTSxTQUFTLEdBQUcsSUFBSSxzQkFBUyxFQUFFLENBQUE7SUFDakMsTUFBTSxRQUFRLEdBQUcsTUFBTSxTQUFTLENBQUMsY0FBYyxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUU7UUFDbEUsR0FBRyxFQUFFLENBQUM7UUFDTixRQUFRO1FBQ1IsZ0JBQWdCO0tBQ25CLENBQUMsQ0FBQTtJQUNGLE1BQU0sTUFBTSxHQUFHLE1BQU0sU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFBO0lBQ2hFLE9BQU8sTUFBTSxDQUFDLGlCQUFpQixDQUFBO0FBQ25DLENBQUMsQ0FBQTtBQTFDWSxRQUFBLDJCQUEyQiwrQkEwQ3ZDO0FBRUQsb0RBQW9EIn0=