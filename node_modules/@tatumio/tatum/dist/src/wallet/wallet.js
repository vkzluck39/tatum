"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateWallet = exports.generateAlgoWallet = exports.generateAdaWallet = exports.generateXlmWallet = exports.generateXrpWallet = exports.generateNeoWallet = exports.generateLtcWallet = exports.generateTronWallet = exports.generateDogeWallet = exports.generateQtumWallet = exports.generateBtcWallet = exports.generateBchWallet = exports.generateCeloWallet = exports.generateXdcWallet = exports.generateBscWallet = exports.generateFlowWallet = exports.generateEgldWallet = exports.generateOneWallet = exports.generateKlaytnWallet = exports.generatePolygonWallet = exports.generateEthWallet = exports.generateVetWallet = exports.generateBnbWallet = void 0;
const crypto_1 = require("@binance-chain/javascript-sdk/lib/crypto");
const neon_js_1 = __importStar(require("@cityofzion/neon-js"));
const bip39_1 = require("bip39");
const bitcoinjs_lib_1 = require("bitcoinjs-lib");
const ethereumjs_wallet_1 = require("ethereumjs-wallet");
// @ts-ignore
const hdkey_1 = __importDefault(require("hdkey"));
const ripple_lib_1 = require("ripple-lib");
const stellar_sdk_1 = require("stellar-sdk");
const constants_1 = require("../constants");
const model_1 = require("../model");
const cardano_crypto_1 = __importDefault(require("./cardano.crypto"));
const algosdk = require('algosdk');
const base32 = require('base32.js');
/**
 * Generate BnB wallet
 * @param testnet testnet or mainnet version of address
 * @returns wallet
 */
const generateBnbWallet = async (testnet) => {
    const privateKey = crypto_1.generatePrivateKey();
    const prefix = testnet ? 'tbnb' : 'bnb';
    return {
        address: crypto_1.getAddressFromPrivateKey(privateKey, prefix),
        privateKey,
    };
};
exports.generateBnbWallet = generateBnbWallet;
/**
 * Generate VeChain wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateVetWallet = async (testnet, mnem) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.VET_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem));
    const derivePath = hdwallet.derivePath(path);
    return {
        xpub: derivePath.publicExtendedKey().toString(),
        mnemonic: mnem,
    };
};
exports.generateVetWallet = generateVetWallet;
/**
 * Generate Ethereum or any other ERC20 wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateEthWallet = async (testnet, mnem) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.ETH_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem));
    const derivePath = hdwallet.derivePath(path);
    return {
        xpub: derivePath.publicExtendedKey().toString(),
        mnemonic: mnem,
    };
};
exports.generateEthWallet = generateEthWallet;
/**
 * Generate Polygon or any other ERC20 wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generatePolygonWallet = async (testnet, mnem) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.MATIC_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem));
    const derivePath = hdwallet.derivePath(path);
    return {
        xpub: derivePath.publicExtendedKey().toString(),
        mnemonic: mnem,
    };
};
exports.generatePolygonWallet = generatePolygonWallet;
/**
 * Generate Polygon or any other ERC20 wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateKlaytnWallet = async (testnet, mnem) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.KLAYTN_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem));
    const derivePath = hdwallet.derivePath(path);
    return {
        xpub: derivePath.publicExtendedKey().toString(),
        mnemonic: mnem,
    };
};
exports.generateKlaytnWallet = generateKlaytnWallet;
/**
 * Generate Harmony or any other ERC20 wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateOneWallet = async (testnet, mnem) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.ONE_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem));
    const derivePath = hdwallet.derivePath(path);
    return {
        xpub: derivePath.publicExtendedKey().toString(),
        mnemonic: mnem,
    };
};
exports.generateOneWallet = generateOneWallet;
/**
 * Generate EGLD wallet
 * @param testnet
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateEgldWallet = async (mnem) => {
    return {
        mnemonic: mnem,
    };
};
exports.generateEgldWallet = generateEgldWallet;
/**
 * Generate Flow or FUSD wallet
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateFlowWallet = async (mnem) => {
    const hdwallet = hdkey_1.default.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem));
    return {
        mnemonic: mnem,
        xpub: hdwallet.derive(constants_1.FLOW_DERIVATION_PATH).toJSON().xpub,
    };
};
exports.generateFlowWallet = generateFlowWallet;
/**
 * Generate BSC or any other BEP-20 or BEP-721 wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateBscWallet = async (testnet, mnem) => {
    return exports.generateEthWallet(testnet, mnem);
};
exports.generateBscWallet = generateBscWallet;
const generateXdcWallet = async (testnet, mnem) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.XDC_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem));
    const derivePath = hdwallet.derivePath(path);
    return {
        xpub: derivePath.publicExtendedKey().toString(),
        mnemonic: mnem,
    };
};
exports.generateXdcWallet = generateXdcWallet;
/**
 * Generate Celo or any other ERC20 wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateCeloWallet = async (testnet, mnem) => {
    const path = testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.CELO_DERIVATION_PATH;
    const hdwallet = ethereumjs_wallet_1.hdkey.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem));
    const derivePath = hdwallet.derivePath(path);
    return {
        xpub: derivePath.publicExtendedKey().toString(),
        mnemonic: mnem,
    };
};
exports.generateCeloWallet = generateCeloWallet;
/**
 * Generate Bitcoin Cash wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateBchWallet = async (testnet, mnem) => {
    const hdwallet = hdkey_1.default.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem), testnet ? bitcoinjs_lib_1.networks.testnet.bip32 : bitcoinjs_lib_1.networks.bitcoin.bip32);
    return {
        mnemonic: mnem,
        xpub: hdwallet.derive(constants_1.BCH_DERIVATION_PATH).toJSON().xpub,
    };
};
exports.generateBchWallet = generateBchWallet;
/**
 * Generate Bitcoin wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateBtcWallet = async (testnet, mnem) => {
    const hdwallet = hdkey_1.default.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem), testnet ? bitcoinjs_lib_1.networks.testnet.bip32 : bitcoinjs_lib_1.networks.bitcoin.bip32);
    return {
        mnemonic: mnem,
        xpub: hdwallet.derive(testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.BTC_DERIVATION_PATH).toJSON().xpub,
    };
};
exports.generateBtcWallet = generateBtcWallet;
const generateQtumWallet = async (testnet, mnem) => {
    const hdwallet = hdkey_1.default.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem), testnet ? constants_1.QTUM_NETWORK_TESTNET.bip32 : constants_1.QTUM_NETWORK_MAINNET.bip32);
    return {
        mnemonic: mnem,
        xpub: hdwallet.derive(testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.QTUM_DERIVATION_PATH).toJSON().xpub,
    };
};
exports.generateQtumWallet = generateQtumWallet;
/**
 * Generate Doge wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateDogeWallet = async (testnet, mnem) => {
    const hdwallet = hdkey_1.default.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem), testnet ? constants_1.DOGE_TEST_NETWORK.bip32 : constants_1.DOGE_NETWORK.bip32);
    return {
        mnemonic: mnem,
        xpub: hdwallet.derive(testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.DOGE_DERIVATION_PATH).toJSON().xpub,
    };
};
exports.generateDogeWallet = generateDogeWallet;
/**
 * Generate Tron wallet
 * @returns mnemonic for the wallet
 */
const generateTronWallet = async (mnem) => {
    const w = bitcoinjs_lib_1.bip32.fromSeed(await bip39_1.mnemonicToSeed(mnem));
    const bip32Interface = w.derivePath(constants_1.TRON_DERIVATION_PATH);
    return {
        mnemonic: mnem,
        xpub: bip32Interface.publicKey.toString('hex') + bip32Interface.chainCode.toString('hex'),
    };
};
exports.generateTronWallet = generateTronWallet;
/**
 * Generate Litecoin wallet
 * @param testnet testnet or mainnet version of address
 * @param mnem mnemonic seed to use
 * @returns wallet
 */
const generateLtcWallet = async (testnet, mnem) => {
    const hdwallet = hdkey_1.default.fromMasterSeed(await bip39_1.mnemonicToSeed(mnem), testnet ? constants_1.LTC_TEST_NETWORK.bip32 : constants_1.LTC_NETWORK.bip32);
    return {
        mnemonic: mnem,
        xpub: hdwallet.derive(testnet ? constants_1.TESTNET_DERIVATION_PATH : constants_1.LTC_DERIVATION_PATH).toJSON().xpub,
    };
};
exports.generateLtcWallet = generateLtcWallet;
/**
 * Generate Neo address and private key.
 */
const generateNeoWallet = () => {
    const privateKey = neon_js_1.default.create.privateKey();
    return { privateKey, address: new neon_js_1.wallet.Account(privateKey).address };
};
exports.generateNeoWallet = generateNeoWallet;
/**
 * Generate Xrp address and secret.
 */
const generateXrpWallet = () => {
    const { address, secret } = new ripple_lib_1.RippleAPI().generateAddress();
    return { address, secret };
};
exports.generateXrpWallet = generateXrpWallet;
/**
 * Generate Stellar address and secret.
 * @param secret secret of the account to generate address
 */
const generateXlmWallet = (secret) => {
    const keypair = secret ? stellar_sdk_1.Keypair.fromSecret(secret) : stellar_sdk_1.Keypair.random();
    return { address: keypair.publicKey(), secret: keypair.secret() };
};
exports.generateXlmWallet = generateXlmWallet;
/**
 * Generate ADA wallet
 * @param mnemonic mnemonic seed to use
 * @returns wallet
 */
const generateAdaWallet = async (mnemonic) => {
    return { mnemonic, xpub: await cardano_crypto_1.default.generateXPublicKey(mnemonic) };
};
exports.generateAdaWallet = generateAdaWallet;
/**
 * Generate Algo wallet
 * @param mnem mnemonic seed to use
 * @returns address and secret
 */
const generateAlgoWallet = async (mnem) => {
    const account = mnem ? algosdk.mnemonicToSecretKey(mnem) : algosdk.generateAccount();
    const encoder = new base32.Encoder({ type: 'rfc4648' });
    const secret = encoder.write(account.sk).finalize();
    return {
        address: account.addr,
        secret: secret,
    };
};
exports.generateAlgoWallet = generateAlgoWallet;
/**
 * Generate wallet
 * @param currency blockchain to generate wallet for
 * @param testnet testnet or mainnet version of address
 * @param mnemonic mnemonic seed to use. If not present, new one will be generated
 * @returns wallet or a combination of address and private key
 */
const generateWallet = (currency, testnet, mnemonic) => {
    const mnem = mnemonic ? mnemonic : bip39_1.generateMnemonic(256);
    switch (currency) {
        case model_1.Currency.BTC:
            return exports.generateBtcWallet(testnet, mnem);
        case model_1.Currency.DOGE:
            return exports.generateDogeWallet(testnet, mnem);
        case model_1.Currency.LTC:
            return exports.generateLtcWallet(testnet, mnem);
        case model_1.Currency.BCH:
            return exports.generateBchWallet(testnet, mnem);
        case model_1.Currency.TRON:
        case model_1.Currency.USDT_TRON:
        case model_1.Currency.INRT_TRON:
            return exports.generateTronWallet(mnem);
        case model_1.Currency.FLOW:
        case model_1.Currency.FUSD:
            return exports.generateFlowWallet(mnem);
        case model_1.Currency.CELO:
        case model_1.Currency.CEUR:
        case model_1.Currency.CUSD:
            return exports.generateCeloWallet(testnet, mnem);
        case model_1.Currency.ONE:
            return exports.generateOneWallet(testnet, mnem);
        case model_1.Currency.QTUM:
            return exports.generateQtumWallet(testnet, mnem);
        case model_1.Currency.KLAY:
            return exports.generateKlaytnWallet(testnet, mnem);
        case model_1.Currency.EGLD:
            return exports.generateEgldWallet(mnem);
        case model_1.Currency.USDT:
        case model_1.Currency.WBTC:
        case model_1.Currency.LEO:
        case model_1.Currency.REVV:
        case model_1.Currency.LATOKEN:
        case model_1.Currency.COIIN:
        case model_1.Currency.SAND:
        case model_1.Currency.LINK:
        case model_1.Currency.UNI:
        case model_1.Currency.FREE:
        case model_1.Currency.MKR:
        case model_1.Currency.USDC:
        case model_1.Currency.BAT:
        case model_1.Currency.TUSD:
        case model_1.Currency.BUSD:
        case model_1.Currency.USDC_BSC:
        case model_1.Currency.COIIN_BSC:
        case model_1.Currency.B2U_BSC:
        case model_1.Currency.GMC:
        case model_1.Currency.GMC_BSC:
        case model_1.Currency.PAX:
        case model_1.Currency.PAXG:
        case model_1.Currency.PLTC:
        case model_1.Currency.XCON:
        case model_1.Currency.ETH:
        case model_1.Currency.BSC:
        case model_1.Currency.BETH:
        case model_1.Currency.GAMEE:
        case model_1.Currency.CAKE:
        case model_1.Currency.MATIC_ETH:
        case model_1.Currency.HAG:
        case model_1.Currency.BUSD_BSC:
        case model_1.Currency.BBTC:
        case model_1.Currency.BADA:
        case model_1.Currency.WBNB:
        case model_1.Currency.BDOT:
        case model_1.Currency.BXRP:
        case model_1.Currency.BLTC:
        case model_1.Currency.BBCH:
        case model_1.Currency.MMY:
            return exports.generateEthWallet(testnet, mnem);
        case model_1.Currency.MATIC:
        case model_1.Currency.USDC_MATIC:
        case model_1.Currency.USDT_MATIC:
            return exports.generatePolygonWallet(testnet, mnem);
        case model_1.Currency.XDC:
            return exports.generateXdcWallet(testnet, mnem);
        case model_1.Currency.XRP:
            return exports.generateXrpWallet();
        case model_1.Currency.XLM:
            return exports.generateXlmWallet();
        case model_1.Currency.VET:
            return exports.generateVetWallet(testnet, mnem);
        case model_1.Currency.NEO:
            return exports.generateNeoWallet();
        case model_1.Currency.BNB:
            return exports.generateBnbWallet(testnet);
        case model_1.Currency.ADA:
            return exports.generateAdaWallet(mnem);
        case model_1.Currency.ALGO:
            return exports.generateAlgoWallet(mnemonic);
        default:
            throw new Error('Unsupported blockchain.');
    }
};
exports.generateWallet = generateWallet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid2FsbGV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3dhbGxldC93YWxsZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHFFQUF3RztBQUN4RywrREFBbUQ7QUFDbkQsaUNBQXlEO0FBQ3pELGlEQUFnRDtBQUNoRCx5REFBc0Q7QUFDdEQsYUFBYTtBQUNiLGtEQUEwQjtBQUMxQiwyQ0FBdUM7QUFDdkMsNkNBQXNDO0FBQ3RDLDRDQXNCc0I7QUFDdEIsb0NBQW9DO0FBQ3BDLHNFQUF1QztBQUV2QyxNQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDbkMsTUFBTSxNQUFNLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBZXBDOzs7O0dBSUc7QUFDSSxNQUFNLGlCQUFpQixHQUFHLEtBQUssRUFBRSxPQUFnQixFQUFFLEVBQUU7SUFDMUQsTUFBTSxVQUFVLEdBQUcsMkJBQWtCLEVBQUUsQ0FBQTtJQUN2QyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFBO0lBQ3ZDLE9BQU87UUFDTCxPQUFPLEVBQUUsaUNBQXdCLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQztRQUNyRCxVQUFVO0tBQ1gsQ0FBQTtBQUNILENBQUMsQ0FBQTtBQVBZLFFBQUEsaUJBQWlCLHFCQU83QjtBQUVEOzs7OztHQUtHO0FBQ0ksTUFBTSxpQkFBaUIsR0FBRyxLQUFLLEVBQUUsT0FBZ0IsRUFBRSxJQUFZLEVBQW1CLEVBQUU7SUFDekYsTUFBTSxJQUFJLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxtQ0FBdUIsQ0FBQyxDQUFDLENBQUMsK0JBQW1CLENBQUE7SUFDcEUsTUFBTSxRQUFRLEdBQUcseUJBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxzQkFBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUE7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